####垃圾回收、循环引用和弱引用

Python使用了自动化内存管理，这种管理机制以引用计数为基础，同时也引入了标记-清除和分代收集两种机制为辅的策略。

	typedef struct_object {
    	/* 引用计数 */
    	int ob_refcnt;
    	/* 对象指针 */
   		struct_typeobject *ob_type;
	} PyObject;



####增加引用计数的宏定义
	#define Py_INCREF(op)   ((op)->ob_refcnt++)
####减少引用计数的宏定义
	#define Py_DECREF(op) \ //减少计数
    if (--(op)->ob_refcnt != 0) \
        ; \
    else \
        __Py_Dealloc((PyObject *)(op))
        
####导致引用计数+1的情况

* 对象被创建， 例如：a = 23
* 对象被引用， 例如  b = a
* 对象被作为参数，传入到一个函数中，例如f（a）
* 对象作为一个元素，存储在容器中，例如，list1 = [a ,a]

####导致引用计数-1的情况
* 对象的别名被显示销毁 例如del a
* 对象的别名被赋予新的对象 例如 a = 24
* 一个对象离开他的作用域，例如函数f执行完毕时，f函数中的局部变量（全局变量不会）
* 对象所在容器被销毁，或从容器中删除对象

		引用计数问题可能会导致循环引用问题，而循环引用会导致内存泄漏，如下：
		# 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收
		# 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效
		# 如果不想造成循环引用可以使用弱引用
		list1 = []
		list2 = [] 
		list1.append(list2)
		list2.append(list1)
		
		为了解决这个问题，python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果第一代的垃圾检查中对象存活了下来，该对象就会放到第二代中，
		同理在第二代垃圾检查中对象存活下来，该对象就会放到第三代中。
		
####一下情况会导致垃圾回收
* 调用gc.collect()
* gc模块的计数器达到阀值
* 程序退出

如果循环引用中两个对象都定义了 ____del_____方法，gc模块不会销毁这些不可达对象，因为gc模块不知道先调用哪个对象的____del_____方法,这个问题在Python3.6中得到了解决。

也可以通过*weakref*模块构造弱引用的方式，来解决循环引用的问题
		